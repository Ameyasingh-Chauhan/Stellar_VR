import subprocess
from pathlib import Path
from .utils import ensure_dir
from config import SBS_WIDTH, SBS_HEIGHT, CRF, PIX_FMT, ENCODER, MAX_WORKERS, TARGET_PER_EYE, FPS
from concurrent.futures import ThreadPoolExecutor, as_completed
import cv2
import numpy as np

def _pack_single_frame_pair(l, r, tmp_frames, i):
    """Pack a single left/right frame pair into side-by-side format"""
    L = cv2.imread(str(l))
    R = cv2.imread(str(r))
    sbs = cv2.hconcat([L, R])
    output_path = tmp_frames / f'sbs_{i:06d}.png'
    cv2.imwrite(str(output_path), sbs)
    return output_path

def pack_and_encode(left_dir, right_dir, output_path, audio_path=None, force_8k=False, progress_cb=None):
    left = sorted(Path(left_dir).glob('*.png'))
    right = sorted(Path(right_dir).glob('*.png'))
    assert len(left) == len(right), 'left/right frame count mismatch'
    tmp_frames = Path(Path(output_path).parent)/'sbs_frames'
    ensure_dir(tmp_frames)
    n = len(left)
    
    # Use single-threaded for less resource usage
    for i,(l,r) in enumerate(zip(left,right)):
        L = cv2.imread(str(l))
        R = cv2.imread(str(r))
        sbs = cv2.hconcat([L, R])
        cv2.imwrite(str(tmp_frames / f'sbs_{i:06d}.png'), sbs)
        if progress_cb and i%10==0:
            progress_cb(85 + int(10*(i/n)), f'Packing {i}/{n}')
    
    # encode with ffmpeg and scale to 8K final (8640x4320 for 8K VR180)
    img_pattern = str(tmp_frames / 'sbs_%06d.png')
    final_w = TARGET_PER_EYE * 2  # 8K width (2 * 4320)
    final_h = TARGET_PER_EYE      # 8K height (4320)
    
    cmd = ['ffmpeg','-y','-framerate', str(FPS),'-i', img_pattern]
    if audio_path:
        cmd += ['-i', str(audio_path), '-map', '0:v', '-map', '1:a']
    cmd += ['-vf', f'scale={final_w}:{final_h}', '-c:v', ENCODER, '-crf', str(CRF), '-pix_fmt', PIX_FMT]
    if audio_path:
        cmd += ['-c:a', 'aac', '-b:a', '256k']
    cmd += [str(output_path)]
    subprocess.check_call(cmd)

def pack_and_encode_panoramic_stereo(panoramic_dir, output_path, audio_path=None, force_8k=False, progress_cb=None):
    """
    Encode panoramic stereo frames into final VR180 equirectangular format
    Output: Cinematic resolution based on settings (4K)
    Includes proper spatial encoding for VR180 with cinematic quality
    """
    from config import TARGET_PER_EYE, CRF, PIX_FMT, ENCODER, FPS
    
    panoramic_frames = sorted(Path(panoramic_dir).glob('*.png'))
    n = len(panoramic_frames)
    
    print(f"[PanoramicEncoder] Encoding {n} panoramic stereo frames")
    
    # Use the actual resolution being generated by the pipeline
    final_w = TARGET_PER_EYE * 2  # 8640 width (2 * 4320)
    final_h = TARGET_PER_EYE      # 4320 height
    
    print(f"  - Output resolution: {final_w}x{final_h} (8K VR180)")
    print(f"  - Format: Equirectangular stereo side-by-side")
    print(f"  - Projection: 180Â° horizontal FOV")
    print(f"  - Quality: Cinematic")
    print(f"  - Encoding: H.265 (HEVC) at 100 Mbps bitrate")
    
    if n == 0:
        print("[PanoramicEncoder] Warning: No panoramic frames found, creating blank video")
        # Create a blank frame as fallback
        blank_frame = np.zeros((final_h, final_w, 3), dtype=np.uint8)
        blank_frame_path = Path(panoramic_dir) / 'panoramic_stereo_000000.png'
        cv2.imwrite(str(blank_frame_path), blank_frame)
        n = 1  # Set n to 1 for the single blank frame
    
    # encode with ffmpeg for panoramic stereo with proper VR180 settings
    if n > 0:
        img_pattern = str(Path(panoramic_dir) / 'panoramic_stereo_%06d.png')
    else:
        # Fallback to single frame
        img_pattern = str(Path(panoramic_dir) / 'panoramic_stereo_000000.png')
        n = 1
    
    in_dir = panoramic_dir
    
    # FFmpeg command with Google spatial metadata for VR180 equirectangular
    # Use H.265 (HEVC) encoding with 100 Mbps bitrate for maximum quality
    cmd = [
        'ffmpeg', '-y', 
        '-framerate', str(FPS),
        '-i', img_pattern,
    ]
    
    # Add audio if available (copy without re-encoding as requested)
    if audio_path and Path(audio_path).exists():
        cmd += ['-i', str(audio_path), '-map', '0:v', '-map', '1:a']
    else:
        print("  No audio file found, encoding video only")
    
    # Add video filters for scaling and VR180 metadata
    cmd += [
        '-vf', f'scale={final_w}:{final_h}:flags=lanczos',
        '-c:v', ENCODER,
        '-pix_fmt', PIX_FMT,
        '-crf', str(CRF),
        '-preset', 'veryslow',  # Use veryslow preset for maximum quality at 8K
        '-profile:v', 'main10',  # Use main10 profile for 10-bit HEVC
        '-b:v', '100M',  # Set bitrate to 100 Mbps as required
    ]
    
    # Add spatial metadata for VR180 equirectangular projection
    cmd += [
        '-metadata:s:v:0', 'stereo-mode=left-right',
        '-metadata:s:v:0', 'projection=equirectangular',
        '-metadata:s:v:0', 'spherical=true',
    ]
    
    # Add audio codec if audio is included (copy without re-encoding as requested)
    if audio_path and Path(audio_path).exists():
        cmd += ['-c:a', 'copy']  # Copy audio streams without re-encoding
    
    # Output file
    cmd += [str(output_path)]
    
    print(f"[PanoramicEncoder] Running FFmpeg command: {' '.join(cmd)}")
    subprocess.check_call(cmd)
    print(f"[PanoramicEncoder] Encoding completed successfully")
